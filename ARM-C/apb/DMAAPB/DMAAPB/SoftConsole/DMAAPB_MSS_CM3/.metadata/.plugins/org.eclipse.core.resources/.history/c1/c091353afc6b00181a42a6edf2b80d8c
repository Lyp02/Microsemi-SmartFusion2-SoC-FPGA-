/*******************************************************************************
 * (c) Copyright 2010-2013 Microsemi SoC Products Group.  All rights reserved.
 *
 * PDMA ping pong example. A large amount of memory is transfered requiring
 * multiple DMA transfers. The DMA transfer is initiated then the DMA channel
 * is fed everytime an interrupt is generated by the PDMA hardware block on
 * completion of a buffer transfer.
 *
 * Please refer to the file README.txt for further details about this example.
 *
 * SVN $Revision: 5290 $
 * SVN $Date: 2013-03-23 13:11:28 +0000 (Sat, 23 Mar 2013) $
 */
#include "drivers/mss_pdma/mss_pdma.h"
#define FIC0_BASE_ADDR 0x33000000

/*
 * Size of the data buffer transferred using multiple PDMA transfers.
 */
#define BUFFER_A_SIZE   512

/*
 * Size of each PDMA transfer.
 */
#define DMA_TRANSFER_SIZE    32

/*
 * The g_buffer_a array is used as the source of PDMA transfers.
 */
uint16_t g_buffer_a[BUFFER_A_SIZE];

/*
 * The g_buffer_b array is used as destination of the PDMA transfers.
 */
uint32_t g_buffer_b[BUFFER_A_SIZE];
uint32_t g_buffer_c[BUFFER_A_SIZE];

/*
 * Global variables used to manage ping pong transfer.
 */
uint32_t g_source_addr = 0;
uint32_t g_target_addr = 0;
volatile int32_t g_size_to_send = 0;

/***************************************************************************//**
 * Generate a bit pattern within the buffer passed as parameter.
 */
void load_pattern
(
    uint16_t * buffer,
    uint16_t size
)
{
    uint32_t i;
    static uint32_t increment = 1;
    for(i = 0; i < size; ++i)
    {
        buffer[i] = 3*i+1;
    }
    ++increment;
}

void load_pattern2
(
    uint16_t * buffer,
    uint16_t size
)
{
    uint32_t i;
    static uint32_t increment = 1;
    for(i = 0; i < size; ++i)
    {
        buffer[i] = i*i;
    }
    ++increment;
}
/***************************************************************************//**
 * PDMA interrupt handler called when a PDMA transfer has completed.
 */
void ping_pong_handler(void)
{
    uint32_t dma_size;

    /*
     * Check if the last buffer has been reached.
     */
    if(g_size_to_send < DMA_TRANSFER_SIZE)
    {
        dma_size = g_size_to_send;
    }
    else
    {
        dma_size = DMA_TRANSFER_SIZE;
    }

    /*
     * Prepare next buffer to be transferred.
     */
    PDMA_load_next_buffer(PDMA_CHANNEL_0,
                          (uint32_t)g_source_addr,
                          (uint32_t)g_target_addr,
                          dma_size);
    g_source_addr += dma_size * sizeof(uint16_t);
    g_target_addr += dma_size * sizeof(uint32_t);
    g_size_to_send -= dma_size;

    /*
     * Disable PDMA channel 0 interrupts the complete data has been passd to the
     * PDMA driver.
     */
    if(g_size_to_send <= 0)
    {
        PDMA_disable_irq(PDMA_CHANNEL_0);
    }
}

/***************************************************************************//**
 * Initiate PDMA ping pong transfer. The content of buffer_a will be copied
 * using PDMA into buffer_b.
 */
void start_transfer
(
    uint16_t *buffer_a,
    uint16_t *buffer_b,
    uint32_t size
)
{
    /*
     * Register the PDMA handler that will feed the PDMA channel.
     */
    PDMA_set_irq_handler(PDMA_CHANNEL_0, ping_pong_handler);

    /*
     * Disable PDMA channel interrupt while we set setup the transfer and
     * modify the value of global variables used by the PDMA channel
     * interrupt handler.
     */
    PDMA_disable_irq(PDMA_CHANNEL_0);

    /*
     * Initialize global varialbes used to manage the ping pong transfer.
     */
    g_source_addr = (uint32_t)buffer_a;
    g_target_addr = (uint32_t)buffer_b;
    g_size_to_send = size;

    /*
     * Initiate PDMA transfer.
     */
    PDMA_start(PDMA_CHANNEL_0,
               (uint32_t)g_source_addr,
               (uint32_t)g_target_addr,
               DMA_TRANSFER_SIZE);

    g_source_addr += DMA_TRANSFER_SIZE * sizeof(uint16_t);
    g_target_addr += DMA_TRANSFER_SIZE * sizeof(uint32_t);
    g_size_to_send -= DMA_TRANSFER_SIZE;

    /*
     * Prepare second buffer to transfer.
     */
    PDMA_load_next_buffer(PDMA_CHANNEL_0,
                          (uint32_t)g_source_addr,
                          (uint32_t)g_target_addr,
                          DMA_TRANSFER_SIZE);
    g_source_addr += DMA_TRANSFER_SIZE * sizeof(uint16_t);
    g_target_addr += DMA_TRANSFER_SIZE * sizeof(uint32_t);
    g_size_to_send -= DMA_TRANSFER_SIZE;

    /*
     * Enable PDMA interrupt generated by channel 0.
     */
    PDMA_enable_irq(PDMA_CHANNEL_0);
}

/***************************************************************************//**
 * Wait for ping pong PDMA trnasfer to complete by observing the number of data
 * bytes left to transfer.
 */
void wait_transfer_complete(void)
{
    while(g_size_to_send > 0)
    {
        ;
    }
}

/***************************************************************************//**
 * main function.
 */
int main(void)
{
    /*
     *  Initialize PDMA controller.
     */
	uint16_t *FIC0_BASE = (uint16_t *)FIC0_BASE_ADDR;
	PDMA_init();

    /*
     * Configure PDMA channel 0 to perform a memory to memory word transfer
     * incrementing both source and destination address after each transfer.
     */
    PDMA_configure(PDMA_CHANNEL_0,
    		       PDMA_MEM_TO_MEM,
                   PDMA_HALFWORD_TRANSFER | PDMA_LOW_PRIORITY
                                          | PDMA_INC_SRC_TWO_BYTES
                                          | PDMA_INC_DEST_FOUR_BYTES,
                   0);

    *(FIC0_BASE + 0) = 9999;
   // uint32_t data =*(FIC0_BASE + 0);
    uint32_t completed=0;


        volatile uint32_t dummy;

        /*
         * Load pattern into g_buffer_a word array.
         */
        load_pattern(g_buffer_a, BUFFER_A_SIZE);
        load_pattern2(g_buffer_b, BUFFER_A_SIZE);



 //       *(FIC0_BASE + i) = i++;

        /*
         * Transfer from g_buffer_a[] to g_buffer_b.
         */
 //       start_transfer(g_buffer_a, FIC0_BASE, BUFFER_A_SIZE);
 //       start_transfer(g_buffer_a,FIC0_BASE,  BUFFER_A_SIZE);

        PDMA_start(PDMA_CHANNEL_0,
                   (uint32_t)g_buffer_a,
                   (uint32_t)FIC0_BASE,
                   100);
       while(!PDMA_status(PDMA_CHANNEL_0));


        PDMA_start(PDMA_CHANNEL_0,
                   (uint32_t)g_buffer_b,
                   (uint32_t)FIC0_BASE,
                   50);

        PDMA_configure(PDMA_CHANNEL_0,
                       PDMA_MEM_TO_MEM,
                       PDMA_HALFWORD_TRANSFER | PDMA_LOW_PRIORITY
                                              | PDMA_INC_SRC_TWO_BYTES
                                              | PDMA_INC_DEST_FOUR_BYTES,
                       0);
        PDMA_start(PDMA_CHANNEL_0,
                   (uint32_t)FIC0_BASE,
                   (uint32_t)g_buffer_c,
                   50);


        /*
         * Wait for full buffer to be transferred.
         */
        //wait_transfer_complete();

        /*
         * Set a breakpoint on the next line. Adding a watch on the g_buffer_b
         * buffer will show the the content of the buffer change as the DMA
         * transfers take place from g_buffer_a to g_buffer_b.
         */
        ++dummy;


    return 0;
}

